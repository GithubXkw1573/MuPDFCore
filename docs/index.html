<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MuPDFCore: MuPDFCore: Multiplatform .NET Core bindings for MuPDF</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="Doxy.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="icon.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MuPDFCore
   &#160;<span id="projectnumber">1.3.1</span>
   </div>
   <div id="projectbrief">Multiplatform .NET Core bindings for MuPDF</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a>: Multiplatform .NET Core bindings for MuPDF </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_Readme"></a> <img src="icon.svg" alt="" style="pointer-events: none;" width="256" align="right" class="inline"/></p>
<p><b><a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a></b> is a set of multiplatform .NET Core bindings for <a href="https://mupdf.com/">MuPDF</a>. It can render PDF, XPS, EPUB and other formats to raster images returned either as raw bytes, or as image files in multiple formats (including PNG and PSD). It also supports multithreading.</p>
<p>It also includes <b><a class="el" href="namespace_mu_p_d_f_core_1_1_mu_p_d_f_renderer.html">MuPDFCore.MuPDFRenderer</a></b>, an <a class="el" href="namespace_avalonia.html">Avalonia</a> control to display documents compatible with <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> in <a class="el" href="namespace_avalonia.html">Avalonia</a> windows (with multithreaded rendering).</p>
<p>The library is released under the <a href="https://www.gnu.org/licenses/agpl-3.0.html">AGPLv3</a> licence.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Getting started</h1>
<p>The <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> library targets .NET Standard 2.0, thus it can be used in projects that target .NET Standard 2.0+, .NET Core 2.0+, .NET 5.0, .NET Framework 4.6.1 (<a href="#netFrameworkNote">note</a>) and possibly others. <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> includes a pre-compiled native library, thus projects using it can only run on Windows, macOS and Linux x64 operating systems.</p>
<p>To use the library in your project, you should install the <a href="https://www.nuget.org/packages/MuPDFCore/">MuPDFCore NuGet package</a> and/or the <a href="https://www.nuget.org/packages/MuPDFCore.MuPDFRenderer/">MuPDFCore.PDFRenderer NuGet package</a>.</p>
<p><b>Note</b>: you should make sure that end users on Windows install the <a href="https://aka.ms/vs/16/release/vc_redist.x64.exe">Microsoft Visual C++ Redistributable for Visual Studio 2015, 2017 and 2019</a>, otherwise they will get an error message stating that <code>MuPDFWrapper.dll</code> could not be loaded because a module was not found.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Usage</h1>
<h2><a class="anchor" id="autotoc_md3"></a>
Documentation</h2>
<p>Interactive documentation for the library can be accessed from the <a href="https://arklumpus.github.io/MuPDFCore/">documentation website</a>. A <a href="https://arklumpus.github.io/MuPDFCore/MuPDFCore.pdf">PDF reference manual</a> is also available.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Examples</h2>
<p>The <a href="https://github.com/arklumpus/MuPDFCore/tree/master/Demo">Demo</a> folder in the repository contains some examples of how the library can be used to extract pages from a PDF or XPS document, render them to a raster image, or combine them in a new document</p>
<p>The <a href="https://github.com/arklumpus/MuPDFCore/tree/master/PDFViewerDemo">PDFViewerDemo</a> folder contains a complete (though minimal) example of a PDF viewer program built around the <code><a class="el" href="class_mu_p_d_f_core_1_1_mu_p_d_f_renderer_1_1_p_d_f_renderer.html" title="A control to render PDF documents (and other formats), potentally using multiple threads.">MuPDFCore.MuPDFRenderer.PDFRenderer</a></code> control.</p>
<p>Note that these examples intentionally avoid any error handling code: in a production setting, you should typically make sure that calls to <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> library functions are within a <code>try...catch</code> block to handle any resulting <code>MuPDFException</code>s.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
MuPDFCore library</h2>
<p>The first step when using <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> is to create a <code><a class="el" href="class_mu_p_d_f_core_1_1_mu_p_d_f_context.html" title="A wrapper around a MuPDF context object, which contains the exception stack and the resource cache st...">MuPDFCore.MuPDFContext</a></code> object that is used internally by the MuPDF library to store various things:</p>
<div class="fragment"><div class="line">MuPDFContext context = new MuPDFContext();</div>
</div><!-- fragment --><p>This object is <code>IDisposable</code>, therefore you should always call the <code>Dispose()</code> method on it once you are done with it (or, better yet, wrap it in a <code>using</code> directive). In most instances, you will only need one instance of <code>MuPDFContext</code> for your whole application.</p>
<p>Amongst other things, MuPDF uses this context to store a cache of "assets" (e.g. images or fonts) that have been used while rendering documents and that may be needed in future. This requires some memory: by default, the maximum size of this cache store is 256MB; however, if you want to restrict how much memory can be used, you can alter this by providing a <code>long</code> value to constructor, indicating the size in bites for the store. A value of <code>0</code> means that the store can grow up to an unlimited size. Furthermore, you can clear the cache completely by using the <code>MuPDFContext.ClearCache</code> method, or partially by using the <code>MuPDFContext.ShrinkCache</code> method.</p>
<p>Once you have obtained a <code>MuPDFContext</code>, you can use it to open a <code>MuPDFDocument</code>. A document can be opened from a file on disk:</p>
<div class="fragment"><div class="line">MuPDFDocument document = new MuPDFDocument(context, &quot;path/to/file&quot;);</div>
</div><!-- fragment --><p>Or from a <code>byte[]</code> array (in this case, you will have to specify the format of the document):</p>
<div class="fragment"><div class="line">byte[] data;</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">MuPDFDocument document = new MuPDFDocument(context, data, InputFileTypes.PDF);</div>
</div><!-- fragment --><p>Or from a <code>MemoryStream</code> (in this case too, you will have to specify the format of the document):</p>
<div class="fragment"><div class="line">MemoryStream stream;</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">MuPDFDocument document = new MuPDFDocument(context, ref stream, InputFileTypes.PDF);</div>
</div><!-- fragment --><p>The <code>MemoryStream</code> is passed with the <code>ref</code> keyword to indicate that the <code>MuPDFDocument</code> will take care of appropriately disposing it once it finishes using it.</p>
<p>A <code>MuPDFDocument</code> is also <code>IDisposable</code> and should be properly disposed of to avoid memory leaks.</p>
<p><b>Important note</b>: the constructor taking a <code>byte[]</code> and the one taking a <code>MemoryStream</code> will not copy the data bytes before sending them to the native MuPDF library functions. Rather, they will <em>pin them in place</em>. This is a <b>bad thing</b> because it will mess up with the Garbage Collector's management of memory. Therefore, this is only suitable for short-lived objects. If you need to initialise a long-lived document object from memory, you should first copy the data to unmanaged memory and then use one of the constructors that take an <code>IntPtr</code> parameter, e.g.:</p>
<div class="fragment"><div class="line">byte[] data;</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">//Allocate enough unmanaged memory</div>
<div class="line">IntPtr ptr = Marshal.AllocHGlobal(data.Length);</div>
<div class="line"> </div>
<div class="line">//Copy the byte array to unmanaged memory</div>
<div class="line">Marshal.Copy(data, 0, ptr, data.Length);</div>
<div class="line"> </div>
<div class="line">//Wrap the pointer in an IDisposable</div>
<div class="line">IDisposable dispIntPtr = new DisposableIntPtr(ptr);</div>
<div class="line"> </div>
<div class="line">//Create the document</div>
<div class="line">MuPDFDocument document = new MuPDFDocument(ctx, ptr, data.Length, InputFileTypes.PDF, ref dispIntPtr);</div>
</div><!-- fragment --><p>The <code>DisposableIntPtr</code> class is a wrapper around a pointer that calls <code>Marshal.FreeHGlobal</code> on it once it is disposed. Passing it as the final optional parameter of <code>MuPDFDocument</code> constructor (again by reference, to indicate that the document takes ownership of the object) makes sure that the memory is properly freed once the document is disposed.</p>
<p>After having obtained a document, you can do many things with it: for example, you can render a page and save the results to a file on disk, or you can collect multiple pages and combine them in a new document. Code to do this can be found in the <a href="https://github.com/arklumpus/MuPDFCore/blob/master/Demo/Program.cs"><code>Program.cs</code></a> file of the Demo project.</p>
<p>Furthermore, you can render a page directly to memory:</p>
<div class="fragment"><div class="line">byte[] pixelData = document.Render(0, 1, PixelFormats.RGBA);</div>
</div><!-- fragment --><p>This method renders page 0 (i.e. the first page of the document) at a 1x resolution (1pt in the document is equivalent to 1px in the image), preserving alpha (transparency) information, and returns the image as an array of the bytes that constitute the pixel data (four bytes per pixel). A variation of this method allows you to supply a rectangular region of the page that you would like to render, rather than the whole page.</p>
<p>Alternatively, if you already know where the image data should be put (e.g. because you are using some kind of graphics library that lets you manipulate the pixel data of its images), you can use the methods that take an <code>IntPtr</code> destination:</p>
<div class="fragment"><div class="line">IntPtr destination;</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">document.Render(0, 1, PixelFormats.RGBA, destination);</div>
</div><!-- fragment --><p>In this case, <b>you have to make sure that there is enough memory to hold the resulting image</b>! Otherwise, an <code>AccessViolationException</code> will occur and your program will usually fail catastrophically. Since it may sometimes be hard to determine how much memory a particular image will need (especially because of subtle differences in the rounding routines, which can cause images to be 1px larger or shorter than expected), the <code>GetRenderedSize</code> method is provided, which returns the number of bytes that will be needed to render a certain page. For example:</p>
<div class="fragment"><div class="line">//Get the number of bytes that will be necessary to hold the rendered page at the given resolution.</div>
<div class="line">int sizeInBytes = document.GetRenderedSize(0, 1, PixelFormats.RGBA);</div>
<div class="line"> </div>
<div class="line">//Allocate an appropriate amount of memory.</div>
<div class="line">IntPtr destination = Marshal.AllocHGlobal(sizeInBytes);</div>
<div class="line"> </div>
<div class="line">//Again, we use a DisposableIntPtr to make sure that we are freeing the memory when we are done with it.</div>
<div class="line">using (DisposableIntPtr holder = new DisposableIntPtr(destination))</div>
<div class="line">{</div>
<div class="line">    //Make sure that all the parameters match those of the call to GetRenderedSize, or the size of the</div>
<div class="line">    //resulting image may be different than expected! Even a translation of 1px could have catastrophic</div>
<div class="line">    //consequences.</div>
<div class="line">    document.Render(0, 1, PixelFormats.RGBA, destination);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Finally, <b>none of these methods are inherently thread-safe</b>! E.g. you cannot render multiple pages of the same document (nor multiple regions of a single page) by simply performing multiple calls to <code>MuPDFDocument.Render</code> in parallel. For multi-threaded operation, you must instead use a <code>MuPDFMultiThreadedPageRender</code>. You can obtain one from a document:</p>
<div class="fragment"><div class="line">MuPDFMultiThreadedPageRenderer renderer = document.GetMultiThreadedRenderer(0, 2);</div>
</div><!-- fragment --><p>This method obtains an object that can be used to render the first page of the document using two threads. By using the <code>Render</code> method of this object, the page can be rendered. The page will be rendered to a number of separate tiles equal to the number of threads, which will then be your responsibility to appropriately "stitch up" (e.g. if you want to display them on screen, you could just place them appropriately). The size of each tile (and the position it should occupy) can be computed by using the <code>Split</code> method of the <code>RoundedSize</code> struct.</p>
<p>Furthermore, multiple <code>MuPDFMultiThreadedPageRenderer</code>s can be used in parallel, which makes it possible e.g. to render every page in the document at the same time (while also using multiple threads to render each page). The following example will render all the pages in a document at the same time in RGBA format at a 1.5x zoom, using 2 threads for each page:</p>
<div class="fragment"><div class="line">//Create a MuPDFContext with a using statement, so that it gets disposed at the right time.</div>
<div class="line">using MuPDFContext context = new MuPDFContext();</div>
<div class="line"> </div>
<div class="line">//Open the document also with a using statement.</div>
<div class="line">using MuPDFDocument document = new MuPDFDocument(context, &quot;path/to/file.pdf&quot;);</div>
<div class="line"> </div>
<div class="line">//Create arrays to hold the objects for the various pages</div>
<div class="line"> </div>
<div class="line">//Renderers: one per page</div>
<div class="line">MuPDFMultiThreadedPageRenderer[] renderers = new MuPDFMultiThreadedPageRenderer[document.Pages.Count];</div>
<div class="line"> </div>
<div class="line">//Page size: one per page</div>
<div class="line">RoundedSize[] renderedPageSizes = new RoundedSize[document.Pages.Count];</div>
<div class="line"> </div>
<div class="line">//Boundaries of the tiles that make up each page: one array per page, with one element per thread</div>
<div class="line">RoundedRectangle[][] tileBounds = new RoundedRectangle[document.Pages.Count][];</div>
<div class="line"> </div>
<div class="line">//Addresses of the memory areas where the image data of the tiles will be stored: one array per page, with one element per thread</div>
<div class="line">IntPtr[][] destinations = new IntPtr[document.Pages.Count][];</div>
<div class="line"> </div>
<div class="line">//Cycle through the pages in the document to initialise everything</div>
<div class="line">for (int i = 0; i &lt; document.Pages.Count; i++)</div>
<div class="line">{</div>
<div class="line">    //Initialise the renderer for the current page, using two threads (total number of threads: number of pages x 2</div>
<div class="line">    renderers[i] = document.GetMultiThreadedRenderer(i, 2);</div>
<div class="line"> </div>
<div class="line">    //Determine the boundaries of the page when it is rendered with a 1.5x zoom factor</div>
<div class="line">    RoundedRectangle roundedBounds = document.Pages[i].Bounds.Round(1.5);</div>
<div class="line">    renderedPageSizes[i] = new RoundedSize(roundedBounds.Width, roundedBounds.Height);</div>
<div class="line"> </div>
<div class="line">    //Determine the boundaries of each tile by splitting the total size of the page by the number of threads.</div>
<div class="line">    tileBounds[i] = renderedPageSizes[i].Split(renderers[i].ThreadCount);</div>
<div class="line"> </div>
<div class="line">    destinations[i] = new IntPtr[renderers[i].ThreadCount];</div>
<div class="line">    for (int j = 0; j &lt; renderers[i].ThreadCount; j++)</div>
<div class="line">    {</div>
<div class="line">        //Allocate the required memory for the j-th tile of the i-th page.</div>
<div class="line">        //Since we will be rendering with a 24-bit-per-pixel format, the required memory in bytes is height x width x 3.</div>
<div class="line">        destinations[i][j] = Marshal.AllocHGlobal(tileBounds[i][j].Height * tileBounds[i][j].Width * 3);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">//Start the actual rendering operations in parallel.</div>
<div class="line">Parallel.For(0, document.Pages.Count, i =&gt;</div>
<div class="line">{</div>
<div class="line">    renderers[i].Render(renderedPageSizes[i], document.Pages[i].Bounds, destinations[i], PixelFormats.RGB);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">//The code in this for-loop is not really part of MuPDFCore - it just shows an example of using VectSharp to &quot;stitch&quot; the tiles up and produce the full image.</div>
<div class="line">for (int i = 0; i &lt; document.Pages.Count; i++)</div>
<div class="line">{</div>
<div class="line">    //Create a new (empty) image to hold the whole page.</div>
<div class="line">    VectSharp.Page renderedPage = new VectSharp.Page(renderedPageSizes[i].Width, renderedPageSizes[i].Height);</div>
<div class="line"> </div>
<div class="line">    //Draw each tile onto the image.</div>
<div class="line">    for (int j = 0; j &lt; renderers[i].ThreadCount; j++)</div>
<div class="line">    {</div>
<div class="line">        //Create a raster image object containing the pixel data. Yay, we do not need to copy/marshal anything!</div>
<div class="line">        VectSharp.RasterImage tile = new VectSharp.RasterImage(destinations[i][j], tileBounds[i][j].Width, tileBounds[i][j].Height, false, false);</div>
<div class="line"> </div>
<div class="line">        //Draw the tile on the main image page.</div>
<div class="line">        renderedPage.Graphics.DrawRasterImage(tileBounds[i][j].X0, tileBounds[i][j].Y0, tile);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    //Save the full page as a PNG image.</div>
<div class="line">    renderedPage.SaveAsPNG(&quot;page&quot; + i.ToString() + &quot;.png&quot;);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">//Clean-up code.</div>
<div class="line">for (int i = 0; i &lt; document.Pages.Count; i++)</div>
<div class="line">{</div>
<div class="line">    //Release the allocated memory.</div>
<div class="line">    for (int j = 0; j &lt; renderers[i].ThreadCount; j++)</div>
<div class="line">    {</div>
<div class="line">        Marshal.FreeHGlobal(destinations[i][j]);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    //Release the renderer (if you skip this, the quiescent renderer&#39;s threads will not be stopped, and your application will never exit!</div>
<div class="line">    renderers[i].Dispose();</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md6"></a>
Structured text representation</h2>
<p>The <code>GetStructuredTextPage</code> method of the <code>MuPDFDocument</code> class makes it possible to obtain a "structured text" representation of each page of the document. This consists of a <code>MuPDFStructuredTextPage</code> object, which is a collection of 0 or more <code>MuPDFStructuredTextBlock</code>s.</p>
<p>Each <code>MuPDFStructuredTextBlock</code> either represents an image or a block of text, typically a paragraph (though there is no guarantee that this is the case). <code>MuPDFStructuredTextBlock</code>s are themselves collections of <code>MuPDFStructuredTextLine</code>s, and each line is a collection of <code>MuPDFStructuredTextCharacter</code>s (in the case of a block representing an image, it will contain a single line with a single character).</p>
<p><code>MuPDFStructuredTextBlock</code>s and <code>MuPDFStructuredTextLine</code>s have a <code>BoundingBox</code> property that defines a rectangle (in page units) that bounds the contents of the block/line in the page. Similarly, <code>MuPDFStructuredTextCharacter</code>s have a <code>BoundingQuad</code> (rather than being a <code>Rectangle</code>, this is a <code>Quad</code>, i.e. a quadrilater defined by its four vertices, which may or may not be a rectangle). These can be used e.g. to highlight regions of text in the page.</p>
<p>The <code>MuPDFStructuredTextPage</code> also has methods to determine which character contains or is closest to a specified point (useful, for example, to determine on which character the user clicked), to obtain a list of shapes that encompass a specified range of text, and to perform text searches using regular expressions.</p>
<p>The order of the blocks in the page (which affects the definition of a "range" of text and search operations) is the same as returned by the underlying MuPDF library, which is taken from the order the text is drawn in the source file, so may not be accurate. They can be reordered using the <code>Array.Sort</code> method on the <code>StructuredTextBlocks</code> array contained in the <code>MuPDFStructuredTextPage</code> (lines within blocks and characters within lines can be likewise reordered).</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Optical Character Recognition (OCR) using Tesseract</h2>
<p>MuPDF 1.18 (embedded in <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> 1.3.0+) adds support for OCR using the <a href="https://github.com/tesseract-ocr/tesseract">Tesseract</a> library. To access this feature in <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a>, you can use one of the overloads of <code>GetStructuredTextPage</code> that takes a <code>TesseractLanguage</code> argument specifying the language to use for the OCR. This will run the OCR and return a <code>MuPDFStructuredTextPage</code> containing the character information obtained by Tesseract, which can be used normally. Depending on the model being used, the OCR step can take a relatively long time; therefore, the <code>MuPDFDocument</code> class also implements a <code>GetStructuredTextPageAsync</code> method, which does the same thing in an asynchronous way.</p>
<p>Objects of the <code>TesseractLanguage</code> class contain information used to locate the trained language model file that is used by Tesseract. Normally, when using Tesseract, you would have to ensure that the trained language model files are available on the user's computer; however, this class implements some "clever" logic to download the necessary files on demand.</p>
<p>In general, MuPDF provides Tesseract with a "language name" (e.g. <code>"eng"</code>). Tesseract then looks for a file called <code>eng.traineddata</code> either in the folder specified by the <code>TESSDATA_PREFIX</code> environment variable, or, if the variable is not defined, in a subfolder of the current working directory called <code>tessdata</code>. <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> manipulates the value of <code>TESSDATA_PREFIX</code> (at the process level) and the language name in order to specify the language file.</p>
<p>The <code>TesseractLanguage</code> class has multiple constructors:</p>
<ul>
<li><code>TesseractLanguage(string prefix, string language)</code>: this constructor is used to directly specify the value of <code>TESSDATA_PREFIX</code> and the language name. The library does not process these in any way. If <code>prefix</code> is <code>null</code>, the value of <code>TESSDATA_PREFIX</code> is not changed, and Tesseract uses the system value.</li>
<li><code>TesseractLanguage(string fileName)</code>: with this constructor, you can directly specify the path to a trained language model file. You can obtain such a file from <a href="https://github.com/tesseract-ocr/tessdata_fast">the tessdata_fast repository</a> or from <a href="https://github.com/tesseract-ocr/tessdata_best">the tessdata_best repository</a>. If the file does not have a <code>.traineddata</code> extension, it will be copied in a temporary location.</li>
<li><p class="startli"><code>TesseractLanguage(Fast language, bool useAnyCached = false)</code> \ <code>TesseractLanguage(FastScript language, bool useAnyCached = false)</code> \ <code>TesseractLanguage(Best language, bool useAnyCached = false)</code> \ <code>TesseractLanguage(BestScript language, bool useAnyCached = false)</code></p>
<p class="startli">With these constructors, you can specify a language from the list of available languages defined in the <code>TesseractLanguage.Fast</code>, <code>TesseractLanguage.FastScript</code>, <code>TesseractLanguage.Best</code>, and <code>TesseractLanguage.BestScript</code> enums.</p>
<p class="startli"><a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> will then look for the trained model file corresponding to the selected language, relative to the <em>path of the executable</em>, in a folder called <code>tessdata/fast</code> and then in a folder called <code>fast</code> (or <code>best</code>, depending on the overload; for the overloads taking a script name, it looks in <code>tessdata/fast/script</code> or <code>fast/script</code> instead).</p>
<p class="startli">If the language file is not found in either of these folders, it then looks for it in a subfolder called <code>tessdata/fast</code> in <code>Environment.SpecialFolder.LocalApplicationData</code>. If the optional argument <code>useAnyCached</code> is <code>true</code>, it also looks for the language file in the same folder as the executable, and then in the <code>best</code> (or <code>fast</code>) subfolders. In this case, for example, if the language file for <code>TesseractLanguage.Fast.Eng</code> is not available, but the file for <code>TesseractLanguage.Best.Eng</code> is available, the latter will be used.</p>
<p class="startli">Finally, if the language file could not be found in any of the possible paths, <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> will download it from the appropriate repository and place it in the appropriate subfolder of the <code>tessdata</code> folder in <code>Environment.SpecialFolder.LocalApplicationData</code>. The file will then be reused as necessary.</p>
<p class="startli">The <code>TESSDATA_PREFIX</code> and language name will then be set accordingly to where the file was located.</p>
<p class="startli">This means that if you use one of these constructors you do not have to worry about the language files being installed in the right place; as long as the user has an Internet connection, the library will download the language files as necessary.</p>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md8"></a>
MuPDFCore.MuPDFRenderer control</h2>
<p>To use the <code>PDFRenderer</code> control in an <a class="el" href="namespace_avalonia.html">Avalonia</a> application, first of all you need to add it to you <a class="el" href="namespace_avalonia.html">Avalonia</a> <code>Window</code>, e.g. in the XAML:</p>
<div class="fragment"><div class="line">&lt;<span class="keywordtype">Window</span> <span class="keyword">xmlns</span>=<span class="stringliteral">&quot;https://github.com/avaloniaui&quot;</span></div>
<div class="line">        ...</div>
<div class="line">        <span class="keyword">xmlns:mupdf</span>=<span class="stringliteral">&quot;clr-namespace:MuPDFCore.MuPDFRenderer;assembly=MuPDFCore.MuPDFRenderer&quot;</span></div>
<div class="line">        <span class="keyword">Opened</span>=<span class="stringliteral">&quot;WindowOpened&quot;</span></div>
<div class="line">        ... &gt;</div>
<div class="line">    &lt;<span class="keywordtype">mupdf:PDFRenderer</span> <span class="keyword">Name</span>=<span class="stringliteral">&quot;MuPDFRenderer&quot;</span> /&gt;</div>
<div class="line">&lt;/<span class="keywordtype">Window</span>&gt;</div>
</div><!-- fragment --><p>You then need to initialise it from the backing code, e.g. in a <code>WindowOpened</code> event:</p>
<div class="fragment"><div class="line">private void WindowOpened(object sender, EventArgs e)</div>
<div class="line">{</div>
<div class="line">    this.FindControl&lt;PDFRenderer&gt;(&quot;MuPDFRenderer&quot;).Initialize(&quot;path/to/file.pdf&quot;);</div>
<div class="line">}</div>
</div><!-- fragment --><p>This way, the renderer will start showing the first page of the specified document, using a number of rendering threads that is decided based on the number of processors in the computer. There are many other ways to initialise a PDFRenderer, so make sure to look at the <a href="https://arklumpus.github.io/MuPDFCore/">documentation</a> to see the other possibilities!</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Building from source</h1>
<p>Building the <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> library from source requires the following steps:</p>
<ol type="1">
<li>Building the <code>libmupdf</code> native library</li>
<li>Building the <code>MuPDFWrapper</code> native library</li>
<li>Creating the <code><a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a></code> library NuGet package</li>
</ol>
<p>Steps 1 and 2 need to be performed on all of Windows, macOS and Linux (no cross-compiling)! Otherwise, some native assets will be missing and it will not be possible to build the NuGet package.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
1. Building libmupdf</h2>
<p>You can download the open-source (GNU AGPL) MuPDF source code from <a href="https://mupdf.com/downloads/index.html">here</a>. You will need to uncompress the source file and compile the library on Windows, macOS and Linux. You need the following files:</p>
<ul>
<li>From Windows:<ul>
<li>libmupdf.lib</li>
</ul>
</li>
<li>From macOS:<ul>
<li>libmupdf.a</li>
<li>libmupdf-third.a</li>
</ul>
</li>
<li>From Linux:<ul>
<li>libmupdf.a</li>
<li>libmupdf-third.a</li>
</ul>
</li>
</ul>
<p>Note that the files from macOS and Linux are different, despite sharing the same name.</p>
<p>For convenience, these compiled files for MuPDF 1.18.0 are included in the <a href="https://github.com/arklumpus/MuPDFCore/tree/master/native/MuPDFWrapper/lib"><code>native/MuPDFWrapper/lib</code> folder</a> of this repository.</p>
<h3><a class="anchor" id="autotoc_md11"></a>
Tips for compiling MuPDF 1.18.0:</h3>
<ul>
<li>On all platforms:<ul>
<li>When following the instructions in <code>thirdparty/tesseract.txt</code>, checkout to the <code>master</code> branch in the <code>tesseract</code> and <code>leptonica</code> repository, instead of the <code>artifex</code> branch as suggested in the instructions.</li>
<li>Apply <a href="http://git.ghostscript.com/?p=mupdf.git;a=commitdiff;h=7995d12fdcddcf4d5bcfa92dfc9425acdf93869e;hp=9ae0f26d81f2185ba538eba517736834b4658a85">this change</a> to <code>source/fitz/ocr-device.c</code> to prevent a runtime error.</li>
<li>Delete or comment line 1051 in <code>source/fitz/ocr-device.c</code> (the one reading <code>fz_save_pixmap_as_png(ctx, ocr-&gt;pixmap, "ass.png");</code>). This line creates a file called <code>ass.png</code> when running the OCR process. This may be useful for debugging, but may have the unintended consequence of overwriting a file with same name, or cause a runtime error if the user does not have write permissions.</li>
</ul>
</li>
<li>On Windows:<ul>
<li>Open the <code>mupdf.sln</code> solution in Visual Studio and select the <code>ReleaseTesseract</code> configuration. Right-click on each project, to open its properties, then go to <code>C/C++</code> &gt; <code>Code Generation</code> and set the <code>Runtime Library</code> to <code>Multi-threaded DLL (/MD)</code> (ignore any project for which this option is not available). Save everything (<code>CTRL+SHIFT+S</code>) and close Visual Studio.</li>
<li>Now, open the <code>x64 Native Tools Command Prompt for VS</code>, move to the folder with the solution file, and build it using <code>msbuild mupdf.sln</code></li>
<li>Then, build again using <code>msbuild mupdf.sln /p:Configuration=Release</code>. Ignore the compilation errors.</li>
<li>Finally, build again using <code>msbuild mupdf.sln /p:Configuration=ReleaseTesseract</code>.</li>
<li>This may still show some errors, but should produce the <code>libmupdf.lib</code> file that is required in the <code>x64/ReleaseTesseract</code> folder (the file should be ~300MB in size).</li>
</ul>
</li>
<li>On Linux:<ul>
<li>Edit the <code>Makefile</code>, adding the <code>-fPIC</code> compiler option at the end of line 27 (which specifies the <code>CFLAGS</code>).</li>
<li>Make sure that you are using a recent enough version of GCC (version 7.3.1 seems to be enough).</li>
</ul>
</li>
<li>On macOS:<ul>
<li>Edit the <code>Makefile</code>, adding the <code>-fPIC</code> compiler option at the end of line 27 (which specifies the <code>CFLAGS</code>). Also add the <code>-std=c++11</code> option at the end of line 59 (which specifies the CXX_CMD).</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md12"></a>
2. Building MuPDFWrapper</h2>
<p>Once you have the required static library files, you should download the <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> source code: <a href="https://github.com/arklumpus/MuPDFCore/archive/v1.3.0.tar.gz">MuPDFCore-1.3.0.tar.gz</a> (or clone the repository) and place the library files in the appropriate subdirectories in the <code>native/MuPDFWrapper/lib/</code> folder.</p>
<p>To compile <code>MuPDFWrapper</code> you will need <a href="https://cmake.org/">CMake</a> and (on Windows) <a href="https://ninja-build.org/">Ninja</a>.</p>
<p>On Windows, the easiest way to get all the required tools is probably to install <a href="https://visualstudio.microsoft.com/it/">Visual Studio</a>. By selecting the "Desktop development with C++" workload you should get everything you need.</p>
<p>On macOS, you will need to install at least the Command-Line Tools for Xcode (if necessary, you should be prompted to do this while you perform the following steps) and CMake.</p>
<p>Once you have everything at the ready, you will have to build MuPDFWrapper on the three platforms.</p>
<h3><a class="anchor" id="autotoc_md13"></a>
Windows</h3>
<ol type="1">
<li>Assuming you have installed Visual Studio, you should open the "__x64__ Native Tools Command Prompt for VS" (you should be able to find this in the Start menu). Take care to open the x64 version, otherwise you will not be able to compile the library. A normal command propmpt will not work, either.</li>
<li><code>CD</code> to the directory where you have downloaded the <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> source code.</li>
<li><code>CD</code> into the <code>native</code> directory.</li>
<li>Type <code>build</code>. This will start the <code>build.cmd</code> batch script that will delete any previous build and compile the library.</li>
</ol>
<p>After this finishes, you should find a file named <code>MuPDFWrapper.dll</code> in the <code>native/out/build/win-x64/MuPDFWrapper/</code> directory. Leave it there.</p>
<h3><a class="anchor" id="autotoc_md14"></a>
macOS and Linux</h3>
<ol type="1">
<li>Assuming you have everything ready, open a terminal in the folder where you have downloaded the <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> source code.</li>
<li><code>cd</code> into the <code>native</code> directory.</li>
<li>Type <code>chmod +x build.sh</code>.</li>
<li>Type <code>./build.sh</code>. This will delete any previous build and compile the library.</li>
</ol>
<p>After this finishes, you should find a file named <code>libMuPDFWrapper.dylib</code> in the <code>native/out/build/mac-x64/MuPDFWrapper/</code> directory (on macOS) and a file named <code>libMuPDFWrapper.so</code> in the <code>native/out/build/linux-x64/MuPDFWrapper/</code> directory (on Linux). Leave it there.</p>
<h2><a class="anchor" id="autotoc_md15"></a>
3. Creating the MuPDFCore NuGet package</h2>
<p>Once you have the <code>MuPDFWrapper.dll</code>, <code>libMuPDFWrapper.dylib</code> and <code>libMuPDFWrapper.so</code> files, make sure they are in the correct folders (<code>native/out/build/xxx-x64/MuPDFWrapper/</code>), <b>all on the same machine</b>.</p>
<p>To create the <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> NuGet package, you will need the <a href="https://dotnet.microsoft.com/download/dotnet/current">.NET Core 2.0 SDK or higher</a> for your platform. Once you have installed it and have everything ready, open a terminal in the folder where you have downloaded the <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> source code and type:</p>
<div class="fragment"><div class="line">cd MuPDFCore</div>
<div class="line">dotnet pack -c Release</div>
</div><!-- fragment --><p>This will create a NuGet package in <code>MuPDFCore/bin/Release</code>. You can install this package on your projects by adding a local NuGet source.</p>
<h1><a class="anchor" id="autotoc_md16"></a>
Note about MuPDFCore and .NET Framework &lt;a name="netFrameworkNote"&gt;&lt;/a&gt;</h1>
<p>If you wish to use <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> in a .NET Framework project, you will need to manually copy the native MuPDFWrapper library for the platform you are using to the executable directory (this is done automatically if you target .NET core).</p>
<p>One way to obtain the appropriate library files is:</p>
<ol type="1">
<li>Manually download the NuGet package for <a href="https://www.nuget.org/packages/MuPDFCore/">MuPDFCore</a> (click on the "Download package" link on the right).</li>
<li>Rename the <code>.nupkg</code> file so that it has a <code>.zip</code> extension.</li>
<li>Extract the zip file.</li>
<li>Within the extracted folder, the library files are in the <code>runtimes/xxx/native/</code> folder, where <code>xxx</code> is either <code>linux-x64</code>, <code>osx-x64</code> or <code>win-x64</code>, depending on the platform you are using.</li>
</ol>
<p>Make sure you copy the appropriate file to the same folder as the executable! </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
