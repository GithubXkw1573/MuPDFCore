<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MuPDFCore: MuPDFCore: Multiplatform .NET Core bindings for MuPDF</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="Doxy.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="icon.svg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MuPDFCore
   &#160;<span id="projectnumber">1.4.0</span>
   </div>
   <div id="projectbrief">Multiplatform .NET Core bindings for MuPDF</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a>: Multiplatform .NET Core bindings for MuPDF </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md_Readme"></a> <img src="icon.svg" alt="" style="pointer-events: none;" width="256" align="right" class="inline"/></p>
<p><b><a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a></b> is a set of multiplatform .NET Core bindings for <a href="https://mupdf.com/">MuPDF</a>. It can render PDF, XPS, EPUB and other formats to raster images returned either as raw bytes, or as image files in multiple formats (including PNG and PSD). It also supports multithreading.</p>
<p>It also includes <b><a class="el" href="namespace_mu_p_d_f_core_1_1_mu_p_d_f_renderer.html">MuPDFCore.MuPDFRenderer</a></b>, an <a class="el" href="namespace_avalonia.html">Avalonia</a> control to display documents compatible with <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> in <a class="el" href="namespace_avalonia.html">Avalonia</a> windows (with multithreaded rendering).</p>
<p>The library is released under the <a href="https://www.gnu.org/licenses/agpl-3.0.html">AGPLv3</a> licence.</p>
<h1><a class="anchor" id="autotoc_md1"></a>
Getting started</h1>
<p>The <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> library targets .NET Standard 2.0, thus it can be used in projects that target .NET Standard 2.0+, .NET Core 2.0+, .NET 5.0+, .NET Framework 4.6.1 (<a href="#netFrameworkNote">note</a>) and possibly others. <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> includes a pre-compiled native library, which currently supports the following platforms:</p>
<ul>
<li>Windows x86 (32 bit)</li>
<li>Windows x64 (64 bit)</li>
<li>Windows arm64 (ARM 64 bit)</li>
<li>Linux x64 (64 bit)</li>
<li>Linux arm64/aarch64 (ARM 64 bit)</li>
<li>macOS Intel x86_64 (64 bit)</li>
<li>macOS Apple silicon (ARM 64 bit, without support for the OCR functions)</li>
</ul>
<p>To use the library in your project, you should install the <a href="https://www.nuget.org/packages/MuPDFCore/">MuPDFCore NuGet package</a> and/or the <a href="https://www.nuget.org/packages/MuPDFCore.MuPDFRenderer/">MuPDFCore.PDFRenderer NuGet package</a>. When you publish a program that uses <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a>, the correct native library for the target architecture will automatically be copied to the build folder (but see the <a href="#netFrameworkNote">note</a> for .NET Framework).</p>
<p><b>Note</b>: you should make sure that end users on Windows install the <a href="https://docs.microsoft.com/en-us/cpp/windows/latest-supported-vc-redist?view=msvc-160#visual-studio-2015-2017-2019-and-2022">Microsoft Visual C++ Redistributable for Visual Studio 2015, 2017, 2019 and 2022</a> for their platform, otherwise they will get an error message stating that <code>MuPDFWrapper.dll</code> could not be loaded because a module was not found.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Usage</h1>
<h2><a class="anchor" id="autotoc_md3"></a>
Documentation</h2>
<p>Interactive documentation for the library can be accessed from the <a href="https://arklumpus.github.io/MuPDFCore/">documentation website</a>. A <a href="https://arklumpus.github.io/MuPDFCore/MuPDFCore.pdf">PDF reference manual</a> is also available.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Examples</h2>
<p>The <a href="https://github.com/arklumpus/MuPDFCore/tree/master/Demo">Demo</a> folder in the repository contains some examples of how the library can be used to extract pages from a PDF or XPS document, render them to a raster image, or combine them in a new document</p>
<p>The <a href="https://github.com/arklumpus/MuPDFCore/tree/master/PDFViewerDemo">PDFViewerDemo</a> folder contains a complete (though minimal) example of a PDF viewer program built around the <code><a class="el" href="class_mu_p_d_f_core_1_1_mu_p_d_f_renderer_1_1_p_d_f_renderer.html" title="A control to render PDF documents (and other formats), potentally using multiple threads.">MuPDFCore.MuPDFRenderer.PDFRenderer</a></code> control.</p>
<p>Note that these examples intentionally avoid any error handling code: in a production setting, you should typically make sure that calls to <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> library functions are within a <code>try...catch</code> block to handle any resulting <code>MuPDFException</code>s.</p>
<h2><a class="anchor" id="autotoc_md5"></a>
MuPDFCore library</h2>
<p>The first step when using <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> is to create a <code><a class="el" href="class_mu_p_d_f_core_1_1_mu_p_d_f_context.html" title="A wrapper around a MuPDF context object, which contains the exception stack and the resource cache st...">MuPDFCore.MuPDFContext</a></code> object that is used internally by the MuPDF library to store various things:</p>
<div class="fragment"><div class="line">MuPDFContext context = new MuPDFContext();</div>
</div><!-- fragment --><p>This object is <code>IDisposable</code>, therefore you should always call the <code>Dispose()</code> method on it once you are done with it (or, better yet, wrap it in a <code>using</code> directive). In most instances, you will only need one instance of <code>MuPDFContext</code> for your whole application.</p>
<p>Amongst other things, MuPDF uses this context to store a cache of "assets" (e.g. images or fonts) that have been used while rendering documents and that may be needed in future. This requires some memory: by default, the maximum size of this cache store is 256MB; however, if you want to restrict how much memory can be used, you can alter this by providing a <code>long</code> value to constructor, indicating the size in bites for the store. A value of <code>0</code> means that the store can grow up to an unlimited size. Furthermore, you can clear the cache completely by using the <code>MuPDFContext.ClearCache</code> method, or partially by using the <code>MuPDFContext.ShrinkCache</code> method.</p>
<p>Once you have obtained a <code>MuPDFContext</code>, you can use it to open a <code>MuPDFDocument</code>. A document can be opened from a file on disk:</p>
<div class="fragment"><div class="line">MuPDFDocument document = new MuPDFDocument(context, &quot;path/to/file&quot;);</div>
</div><!-- fragment --><p>Or from a <code>byte[]</code> array (in this case, you will have to specify the format of the document):</p>
<div class="fragment"><div class="line">byte[] data;</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">MuPDFDocument document = new MuPDFDocument(context, data, InputFileTypes.PDF);</div>
</div><!-- fragment --><p>Or from a <code>MemoryStream</code> (in this case too, you will have to specify the format of the document):</p>
<div class="fragment"><div class="line">MemoryStream stream;</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">MuPDFDocument document = new MuPDFDocument(context, ref stream, InputFileTypes.PDF);</div>
</div><!-- fragment --><p>The <code>MemoryStream</code> is passed with the <code>ref</code> keyword to indicate that the <code>MuPDFDocument</code> will take care of appropriately disposing it once it finishes using it.</p>
<p>A <code>MuPDFDocument</code> is also <code>IDisposable</code> and should be properly disposed of to avoid memory leaks.</p>
<p><b>Important note</b>: the constructor taking a <code>byte[]</code> and the one taking a <code>MemoryStream</code> will not copy the data bytes before sending them to the native MuPDF library functions. Rather, they will <em>pin them in place</em>. This is a <b>bad thing</b> because it will mess up with the Garbage Collector's management of memory. Therefore, this is only suitable for short-lived objects. If you need to initialise a long-lived document object from memory, you should first copy the data to unmanaged memory and then use one of the constructors that take an <code>IntPtr</code> parameter, e.g.:</p>
<div class="fragment"><div class="line">byte[] data;</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">//Allocate enough unmanaged memory</div>
<div class="line">IntPtr ptr = Marshal.AllocHGlobal(data.Length);</div>
<div class="line"> </div>
<div class="line">//Copy the byte array to unmanaged memory</div>
<div class="line">Marshal.Copy(data, 0, ptr, data.Length);</div>
<div class="line"> </div>
<div class="line">//Wrap the pointer in an IDisposable</div>
<div class="line">IDisposable dispIntPtr = new DisposableIntPtr(ptr);</div>
<div class="line"> </div>
<div class="line">//Create the document</div>
<div class="line">MuPDFDocument document = new MuPDFDocument(ctx, ptr, data.Length, InputFileTypes.PDF, ref dispIntPtr);</div>
</div><!-- fragment --><p>The <code>DisposableIntPtr</code> class is a wrapper around a pointer that calls <code>Marshal.FreeHGlobal</code> on it once it is disposed. Passing it as the final optional parameter of <code>MuPDFDocument</code> constructor (again by reference, to indicate that the document takes ownership of the object) makes sure that the memory is properly freed once the document is disposed.</p>
<p>After having obtained a document, you can do many things with it: for example, you can render a page and save the results to a file on disk, or you can collect multiple pages and combine them in a new document. Code to do this can be found in the <a href="https://github.com/arklumpus/MuPDFCore/blob/master/Demo/Program.cs"><code>Program.cs</code></a> file of the Demo project.</p>
<p>Furthermore, you can render a page directly to memory:</p>
<div class="fragment"><div class="line">byte[] pixelData = document.Render(0, 1, PixelFormats.RGBA);</div>
</div><!-- fragment --><p>This method renders page 0 (i.e. the first page of the document) at a 1x resolution (1pt in the document is equivalent to 1px in the image), preserving alpha (transparency) information, and returns the image as an array of the bytes that constitute the pixel data (four bytes per pixel). A variation of this method allows you to supply a rectangular region of the page that you would like to render, rather than the whole page.</p>
<p>Alternatively, if you already know where the image data should be put (e.g. because you are using some kind of graphics library that lets you manipulate the pixel data of its images), you can use the methods that take an <code>IntPtr</code> destination:</p>
<div class="fragment"><div class="line">IntPtr destination;</div>
<div class="line"> </div>
<div class="line">...</div>
<div class="line"> </div>
<div class="line">document.Render(0, 1, PixelFormats.RGBA, destination);</div>
</div><!-- fragment --><p>In this case, <b>you have to make sure that there is enough memory to hold the resulting image</b>! Otherwise, an <code>AccessViolationException</code> will occur and your program will usually fail catastrophically. Since it may sometimes be hard to determine how much memory a particular image will need (especially because of subtle differences in the rounding routines, which can cause images to be 1px larger or shorter than expected), the <code>GetRenderedSize</code> method is provided, which returns the number of bytes that will be needed to render a certain page. For example:</p>
<div class="fragment"><div class="line">//Get the number of bytes that will be necessary to hold the rendered page at the given resolution.</div>
<div class="line">int sizeInBytes = document.GetRenderedSize(0, 1, PixelFormats.RGBA);</div>
<div class="line"> </div>
<div class="line">//Allocate an appropriate amount of memory.</div>
<div class="line">IntPtr destination = Marshal.AllocHGlobal(sizeInBytes);</div>
<div class="line"> </div>
<div class="line">//Again, we use a DisposableIntPtr to make sure that we are freeing the memory when we are done with it.</div>
<div class="line">using (DisposableIntPtr holder = new DisposableIntPtr(destination))</div>
<div class="line">{</div>
<div class="line">    //Make sure that all the parameters match those of the call to GetRenderedSize, or the size of the</div>
<div class="line">    //resulting image may be different than expected! Even a translation of 1px could have catastrophic</div>
<div class="line">    //consequences.</div>
<div class="line">    document.Render(0, 1, PixelFormats.RGBA, destination);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Finally, <b>none of these methods are inherently thread-safe</b>! E.g. you cannot render multiple pages of the same document (nor multiple regions of a single page) by simply performing multiple calls to <code>MuPDFDocument.Render</code> in parallel. For multi-threaded operation, you must instead use a <code>MuPDFMultiThreadedPageRender</code>. You can obtain one from a document:</p>
<div class="fragment"><div class="line">MuPDFMultiThreadedPageRenderer renderer = document.GetMultiThreadedRenderer(0, 2);</div>
</div><!-- fragment --><p>This method obtains an object that can be used to render the first page of the document using two threads. By using the <code>Render</code> method of this object, the page can be rendered. The page will be rendered to a number of separate tiles equal to the number of threads, which will then be your responsibility to appropriately "stitch up" (e.g. if you want to display them on screen, you could just place them appropriately). The size of each tile (and the position it should occupy) can be computed by using the <code>Split</code> method of the <code>RoundedSize</code> struct.</p>
<p>Furthermore, multiple <code>MuPDFMultiThreadedPageRenderer</code>s can be used in parallel, which makes it possible e.g. to render every page in the document at the same time (while also using multiple threads to render each page). The following example will render all the pages in a document at the same time in RGBA format at a 1.5x zoom, using 2 threads for each page:</p>
<div class="fragment"><div class="line">//Create a MuPDFContext with a using statement, so that it gets disposed at the right time.</div>
<div class="line">using MuPDFContext context = new MuPDFContext();</div>
<div class="line"> </div>
<div class="line">//Open the document also with a using statement.</div>
<div class="line">using MuPDFDocument document = new MuPDFDocument(context, &quot;path/to/file.pdf&quot;);</div>
<div class="line"> </div>
<div class="line">//Create arrays to hold the objects for the various pages</div>
<div class="line"> </div>
<div class="line">//Renderers: one per page</div>
<div class="line">MuPDFMultiThreadedPageRenderer[] renderers = new MuPDFMultiThreadedPageRenderer[document.Pages.Count];</div>
<div class="line"> </div>
<div class="line">//Page size: one per page</div>
<div class="line">RoundedSize[] renderedPageSizes = new RoundedSize[document.Pages.Count];</div>
<div class="line"> </div>
<div class="line">//Boundaries of the tiles that make up each page: one array per page, with one element per thread</div>
<div class="line">RoundedRectangle[][] tileBounds = new RoundedRectangle[document.Pages.Count][];</div>
<div class="line"> </div>
<div class="line">//Addresses of the memory areas where the image data of the tiles will be stored: one array per page, with one element per thread</div>
<div class="line">IntPtr[][] destinations = new IntPtr[document.Pages.Count][];</div>
<div class="line"> </div>
<div class="line">//Cycle through the pages in the document to initialise everything</div>
<div class="line">for (int i = 0; i &lt; document.Pages.Count; i++)</div>
<div class="line">{</div>
<div class="line">    //Initialise the renderer for the current page, using two threads (total number of threads: number of pages x 2</div>
<div class="line">    renderers[i] = document.GetMultiThreadedRenderer(i, 2);</div>
<div class="line"> </div>
<div class="line">    //Determine the boundaries of the page when it is rendered with a 1.5x zoom factor</div>
<div class="line">    RoundedRectangle roundedBounds = document.Pages[i].Bounds.Round(1.5);</div>
<div class="line">    renderedPageSizes[i] = new RoundedSize(roundedBounds.Width, roundedBounds.Height);</div>
<div class="line"> </div>
<div class="line">    //Determine the boundaries of each tile by splitting the total size of the page by the number of threads.</div>
<div class="line">    tileBounds[i] = renderedPageSizes[i].Split(renderers[i].ThreadCount);</div>
<div class="line"> </div>
<div class="line">    destinations[i] = new IntPtr[renderers[i].ThreadCount];</div>
<div class="line">    for (int j = 0; j &lt; renderers[i].ThreadCount; j++)</div>
<div class="line">    {</div>
<div class="line">        //Allocate the required memory for the j-th tile of the i-th page.</div>
<div class="line">        //Since we will be rendering with a 24-bit-per-pixel format, the required memory in bytes is height x width x 3.</div>
<div class="line">        destinations[i][j] = Marshal.AllocHGlobal(tileBounds[i][j].Height * tileBounds[i][j].Width * 3);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">//Start the actual rendering operations in parallel.</div>
<div class="line">Parallel.For(0, document.Pages.Count, i =&gt;</div>
<div class="line">{</div>
<div class="line">    renderers[i].Render(renderedPageSizes[i], document.Pages[i].Bounds, destinations[i], PixelFormats.RGB);</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">//The code in this for-loop is not really part of MuPDFCore - it just shows an example of using VectSharp to &quot;stitch&quot; the tiles up and produce the full image.</div>
<div class="line">for (int i = 0; i &lt; document.Pages.Count; i++)</div>
<div class="line">{</div>
<div class="line">    //Create a new (empty) image to hold the whole page.</div>
<div class="line">    VectSharp.Page renderedPage = new VectSharp.Page(renderedPageSizes[i].Width, renderedPageSizes[i].Height);</div>
<div class="line"> </div>
<div class="line">    //Draw each tile onto the image.</div>
<div class="line">    for (int j = 0; j &lt; renderers[i].ThreadCount; j++)</div>
<div class="line">    {</div>
<div class="line">        //Create a raster image object containing the pixel data. Yay, we do not need to copy/marshal anything!</div>
<div class="line">        VectSharp.RasterImage tile = new VectSharp.RasterImage(destinations[i][j], tileBounds[i][j].Width, tileBounds[i][j].Height, false, false);</div>
<div class="line"> </div>
<div class="line">        //Draw the tile on the main image page.</div>
<div class="line">        renderedPage.Graphics.DrawRasterImage(tileBounds[i][j].X0, tileBounds[i][j].Y0, tile);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    //Save the full page as a PNG image.</div>
<div class="line">    renderedPage.SaveAsPNG(&quot;page&quot; + i.ToString() + &quot;.png&quot;);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">//Clean-up code.</div>
<div class="line">for (int i = 0; i &lt; document.Pages.Count; i++)</div>
<div class="line">{</div>
<div class="line">    //Release the allocated memory.</div>
<div class="line">    for (int j = 0; j &lt; renderers[i].ThreadCount; j++)</div>
<div class="line">    {</div>
<div class="line">        Marshal.FreeHGlobal(destinations[i][j]);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    //Release the renderer (if you skip this, the quiescent renderer&#39;s threads will not be stopped, and your application will never exit!</div>
<div class="line">    renderers[i].Dispose();</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md6"></a>
Structured text representation</h2>
<p>The <code>GetStructuredTextPage</code> method of the <code>MuPDFDocument</code> class makes it possible to obtain a "structured text" representation of each page of the document. This consists of a <code>MuPDFStructuredTextPage</code> object, which is a collection of 0 or more <code>MuPDFStructuredTextBlock</code>s.</p>
<p>Each <code>MuPDFStructuredTextBlock</code> either represents an image or a block of text, typically a paragraph (though there is no guarantee that this is the case). <code>MuPDFStructuredTextBlock</code>s are themselves collections of <code>MuPDFStructuredTextLine</code>s, and each line is a collection of <code>MuPDFStructuredTextCharacter</code>s (in the case of a block representing an image, it will contain a single line with a single character).</p>
<p><code>MuPDFStructuredTextBlock</code>s and <code>MuPDFStructuredTextLine</code>s have a <code>BoundingBox</code> property that defines a rectangle (in page units) that bounds the contents of the block/line in the page. Similarly, <code>MuPDFStructuredTextCharacter</code>s have a <code>BoundingQuad</code> (rather than being a <code>Rectangle</code>, this is a <code>Quad</code>, i.e. a quadrilater defined by its four vertices, which may or may not be a rectangle). These can be used e.g. to highlight regions of text in the page.</p>
<p>The <code>MuPDFStructuredTextPage</code> also has methods to determine which character contains or is closest to a specified point (useful, for example, to determine on which character the user clicked), to obtain a list of shapes that encompass a specified range of text, and to perform text searches using regular expressions.</p>
<p>The order of the blocks in the page (which affects the definition of a "range" of text and search operations) is the same as returned by the underlying MuPDF library, which is taken from the order the text is drawn in the source file, so may not be accurate. They can be reordered using the <code>Array.Sort</code> method on the <code>StructuredTextBlocks</code> array contained in the <code>MuPDFStructuredTextPage</code> (lines within blocks and characters within lines can be likewise reordered).</p>
<h2><a class="anchor" id="autotoc_md7"></a>
Optical Character Recognition (OCR) using Tesseract</h2>
<p>MuPDF 1.18+ (embedded in <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> 1.3.0+) adds support for OCR using the <a href="https://github.com/tesseract-ocr/tesseract">Tesseract</a> library. To access this feature in <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a>, you can use one of the overloads of <code>GetStructuredTextPage</code> that takes a <code>TesseractLanguage</code> argument specifying the language to use for the OCR. This will run the OCR and return a <code>MuPDFStructuredTextPage</code> containing the character information obtained by Tesseract, which can be used normally. Depending on the model being used, the OCR step can take a relatively long time; therefore, the <code>MuPDFDocument</code> class also implements a <code>GetStructuredTextPageAsync</code> method, which does the same thing in an asynchronous way.</p>
<p>Objects of the <code>TesseractLanguage</code> class contain information used to locate the trained language model file that is used by Tesseract. Normally, when using Tesseract, you would have to ensure that the trained language model files are available on the user's computer; however, this class implements some "clever" logic to download the necessary files on demand.</p>
<p>In general, MuPDF provides Tesseract with a "language name" (e.g. <code>"eng"</code>). Tesseract then looks for a file called <code>eng.traineddata</code> either in the folder specified by the <code>TESSDATA_PREFIX</code> environment variable, or, if the variable is not defined, in a subfolder of the current working directory called <code>tessdata</code>. <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> manipulates the value of <code>TESSDATA_PREFIX</code> (at the process level) and the language name in order to specify the language file.</p>
<p>The <code>TesseractLanguage</code> class has multiple constructors:</p>
<ul>
<li><code>TesseractLanguage(string prefix, string language)</code>: this constructor is used to directly specify the value of <code>TESSDATA_PREFIX</code> and the language name. The library does not process these in any way. If <code>prefix</code> is <code>null</code>, the value of <code>TESSDATA_PREFIX</code> is not changed, and Tesseract uses the system value.</li>
<li><code>TesseractLanguage(string fileName)</code>: with this constructor, you can directly specify the path to a trained language model file. You can obtain such a file from <a href="https://github.com/tesseract-ocr/tessdata_fast">the tessdata_fast repository</a> or from <a href="https://github.com/tesseract-ocr/tessdata_best">the tessdata_best repository</a>. If the file does not have a <code>.traineddata</code> extension, it will be copied in a temporary location.</li>
<li><p class="startli"><code>TesseractLanguage(Fast language, bool useAnyCached = false)</code> \ <code>TesseractLanguage(FastScript language, bool useAnyCached = false)</code> \ <code>TesseractLanguage(Best language, bool useAnyCached = false)</code> \ <code>TesseractLanguage(BestScript language, bool useAnyCached = false)</code></p>
<p class="startli">With these constructors, you can specify a language from the list of available languages defined in the <code>TesseractLanguage.Fast</code>, <code>TesseractLanguage.FastScript</code>, <code>TesseractLanguage.Best</code>, and <code>TesseractLanguage.BestScript</code> enums.</p>
<p class="startli"><a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> will then look for the trained model file corresponding to the selected language, relative to the <em>path of the executable</em>, in a folder called <code>tessdata/fast</code> and then in a folder called <code>fast</code> (or <code>best</code>, depending on the overload; for the overloads taking a script name, it looks in <code>tessdata/fast/script</code> or <code>fast/script</code> instead).</p>
<p class="startli">If the language file is not found in either of these folders, it then looks for it in a subfolder called <code>tessdata/fast</code> in <code>Environment.SpecialFolder.LocalApplicationData</code>. If the optional argument <code>useAnyCached</code> is <code>true</code>, it also looks for the language file in the same folder as the executable, and then in the <code>best</code> (or <code>fast</code>) subfolders. In this case, for example, if the language file for <code>TesseractLanguage.Fast.Eng</code> is not available, but the file for <code>TesseractLanguage.Best.Eng</code> is available, the latter will be used.</p>
<p class="startli">Finally, if the language file could not be found in any of the possible paths, <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> will download it from the appropriate repository and place it in the appropriate subfolder of the <code>tessdata</code> folder in <code>Environment.SpecialFolder.LocalApplicationData</code>. The file will then be reused as necessary.</p>
<p class="startli">The <code>TESSDATA_PREFIX</code> and language name will then be set accordingly to where the file was located.</p>
<p class="startli">This means that if you use one of these constructors you do not have to worry about the language files being installed in the right place; as long as the user has an Internet connection, the library will download the language files as necessary.</p>
</li>
</ul>
<p><b>Note</b>: the Tesseract OCR is not supported on macOS on Apple silicon, because I could not find a way to compile the native MuPDF library with Tesseract on this platform (can you help?). If you try to use any OCR method in an app published with target <code>osx-arm64</code>, you will get an exception (you can catch this and fail gracefully). If you need to use the OCR functions on macOS, you should publish with target <code>osx-x64</code> and rely on Rosetta 2 to run your program on Apple silicon Macs.</p>
<h2><a class="anchor" id="autotoc_md8"></a>
MuPDFCore.MuPDFRenderer control</h2>
<p>To use the <code>PDFRenderer</code> control in an <a class="el" href="namespace_avalonia.html">Avalonia</a> application, first of all you need to add it to you <a class="el" href="namespace_avalonia.html">Avalonia</a> <code>Window</code>, e.g. in the XAML:</p>
<div class="fragment"><div class="line">&lt;<span class="keywordtype">Window</span> <span class="keyword">xmlns</span>=<span class="stringliteral">&quot;https://github.com/avaloniaui&quot;</span></div>
<div class="line">        ...</div>
<div class="line">        <span class="keyword">xmlns:mupdf</span>=<span class="stringliteral">&quot;clr-namespace:MuPDFCore.MuPDFRenderer;assembly=MuPDFCore.MuPDFRenderer&quot;</span></div>
<div class="line">        <span class="keyword">Opened</span>=<span class="stringliteral">&quot;WindowOpened&quot;</span></div>
<div class="line">        ... &gt;</div>
<div class="line">    &lt;<span class="keywordtype">mupdf:PDFRenderer</span> <span class="keyword">Name</span>=<span class="stringliteral">&quot;MuPDFRenderer&quot;</span> /&gt;</div>
<div class="line">&lt;/<span class="keywordtype">Window</span>&gt;</div>
</div><!-- fragment --><p>You then need to initialise it from the backing code, e.g. in a <code>WindowOpened</code> event:</p>
<div class="fragment"><div class="line">private void WindowOpened(object sender, EventArgs e)</div>
<div class="line">{</div>
<div class="line">    this.FindControl&lt;PDFRenderer&gt;(&quot;MuPDFRenderer&quot;).Initialize(&quot;path/to/file.pdf&quot;);</div>
<div class="line">}</div>
</div><!-- fragment --><p>This way, the renderer will start showing the first page of the specified document, using a number of rendering threads that is decided based on the number of processors in the computer. There are many other ways to initialise a PDFRenderer, so make sure to look at the <a href="https://arklumpus.github.io/MuPDFCore/">documentation</a> to see the other possibilities!</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Building from source</h1>
<p>Building the <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> library from source requires the following steps:</p>
<ol type="1">
<li>Building the <code>libmupdf</code> native library</li>
<li>Building the <code>MuPDFWrapper</code> native library</li>
<li>Creating the <code><a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a></code> library NuGet package</li>
</ol>
<p>Steps 1 and 2 need to be performed on all of Windows, macOS and Linux, and on the various possible architectures (x86, x64 and arm64 for Windows, x64/Intel and arm64/Apple for macOS, and x64 and arm64 for Linux - no cross-compiling)! Otherwise, some native assets will be missing and it will not be possible to build the NuGet package.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
1. Building libmupdf</h2>
<p>You can download the open-source (GNU AGPL) MuPDF source code from <a href="https://mupdf.com/downloads/index.html">here</a>. You will need to uncompress the source file and compile the library on Windows, macOS and Linux. You need the following files:</p>
<ul>
<li>From Windows (x86, x64, arm64):<ul>
<li>libmupdf.lib</li>
</ul>
</li>
<li>From macOS (Intel - x64, Apple silicon - arm64):<ul>
<li>libmupdf.a</li>
<li>libmupdf-third.a</li>
</ul>
</li>
<li>From Linux (x64, arm64):<ul>
<li>libmupdf.a</li>
<li>libmupdf-third.a</li>
</ul>
</li>
</ul>
<p>Note that the files from macOS and Linux are different, despite sharing the same name.</p>
<p>For convenience, these compiled files for MuPDF 1.19.0 are included in the <a href="https://github.com/arklumpus/MuPDFCore/tree/master/native/MuPDFWrapper/lib"><code>native/MuPDFWrapper/lib</code> folder</a> of this repository.</p>
<h3><a class="anchor" id="autotoc_md11"></a>
Tips for compiling MuPDF 1.19.0:</h3>
<ul>
<li>On all platforms:<ul>
<li>You do not need to follow the instructions in <code>thirdparty/tesseract.txt</code>, as in this version the <em>leptonica</em> and <em>tesseract</em> libraries are already included in the source archive.</li>
<li>Delete or comment line 1082 in <code>source/fitz/ocr-device.c</code> (the one reading <code>fz_save_pixmap_as_png(ctx, ocr-&gt;pixmap, "ass.png");</code>). This line creates a file called <code>ass.png</code> when running the OCR process. This may be useful for debugging, but may have the unintended consequence of overwriting a file with same name, or cause a runtime error if the user does not have write permissions.</li>
<li>Delete or comment line 316 in <code>source/fitz/output.c</code> (the <code>fz_throw</code> invocation within the <code>buffer_seek</code> method - this should leave the <code>buffer_seek</code> method empty). This line throws an exception when a seek operation on a buffer is attempted. The problem is that this makes it impossible to render a document as a PSD image in memory, because the <code>fz_write_pixmap_as_psd</code> method performs a few seek operations. By removing this line, we turn buffer seeks into no-ops; this doesn't seem to have catastrophic side-effects and the PSD documents produced in this way appear to be fine.</li>
</ul>
</li>
<li>On Windows (x64):<ul>
<li>Open the <code>platform/win32/mupdf.sln</code> solution in Visual Studio and select the <code>ReleaseTesseract</code> configuration and <code>x64</code> architecture. Right-click on each project, to open its properties, then go to <code>C/C++</code> &gt; <code>Code Generation</code> and set the <code>Runtime Library</code> to <code>Multi-threaded DLL (/MD)</code> (ignore any project for which this option is not available). Save everything (<code>CTRL+SHIFT+S</code>) and close Visual Studio.</li>
<li>Now, open the <code>x64 Native Tools Command Prompt for VS</code>, move to the folder with the solution file, and build it using <code>msbuild mupdf.sln</code></li>
<li>Then, build again using <code>msbuild mupdf.sln /p:Configuration=Release</code>. Ignore the compilation errors.</li>
<li>Finally, build again using <code>msbuild mupdf.sln /p:Configuration=ReleaseTesseract</code>.</li>
<li>This may still show some errors, but should produce the <code>libmupdf.lib</code> file that is required in the <code>x64/ReleaseTesseract</code> folder (the file should be ~383MB in size).</li>
</ul>
</li>
<li>On Windows (x86):<ul>
<li>Open the <code>platform/win32/mupdf.sln</code> solution in Visual Studio and select the <code>ReleaseTesseract</code> configuration and <code>Win32</code> architecture. Right-click on each project, to open its properties, then go to <code>C/C++</code> &gt; <code>Code Generation</code> and set the <code>Runtime Library</code> to <code>Multi-threaded DLL (/MD)</code> (ignore any project for which this option is not available). Save everything (<code>CTRL+SHIFT+S</code>) and close Visual Studio.</li>
<li>Now, open the <code>x86 Native Tools Command Prompt for VS</code>, move to the folder with the solution file, and build it using <code>msbuild mupdf.sln /p:Platform=Win32</code></li>
<li>Then, build again using <code>msbuild mupdf.sln /p:Configuration=Release /p:Platform=Win32</code>. Ignore the compilation errors.</li>
<li>Finally, build again using <code>msbuild mupdf.sln /p:Configuration=ReleaseTesseract /p:Platform=Win32</code>.</li>
<li>This may still show some errors, but should produce the <code>libmupdf.lib</code> file that is required in the <code>ReleaseTesseract</code> folder (the file should be ~362MB in size).</li>
</ul>
</li>
<li><p class="startli">On Windows (arm64)</p>
<p class="startli">This is going to be a bit more complicated, because it appears that MuPDF is not meant to be built on ARM. These instructions will assume that you are building MuPDF on an ARM machine.</p>
<p class="startli">First of all, make sure that you have installed Visual Studio 2022 and have selected the C++ ARM64 build tools component of the "Desktop development with C++" workload.</p>
<p class="startli"><b>Note</b>: When you install Visual Studio on an ARM machine, it will complain that this is not supported and will be slow. Ignore that warning.</p><ul>
<li>Download and extract the MuPDF source code and follow the instructions for all platforms above.</li>
<li>Add <code>|| defined(_M_ARM64)</code> at the end of line 16 in <code>scripts/tesseract/endianness.h</code>.</li>
<li>Now we need to edit a few files in the <code>thirdparty/tesseract/src/arch</code> folder.<ul>
<li>Comment or delete lines 149-177 (inclusive) in <code>simddetect.cpp</code>. You should now have an empty block between <code># elif defined(_WIN32)</code> and <code>#else</code>. Also comment or delete lines 198-220 (inclusive) and 237-260 (inclusive).</li>
<li>Comment or delete lines 20-22 (inclusive) in <code>dotproductsse.cpp</code>. Replace the whole body of the <code>DotProductSSE</code> method (lines 30-76) with <code>return DotProductNative(u, v, n);</code>.</li>
<li>Comment or delete lines 20-21 (inclusive) in <code>dotproductavx.cpp</code>. Replace the whole body of the <code>DotProductAVX</code> method (lines 29-54) with <code>return DotProductNative(u, v, n);</code>.</li>
<li>Comment or delete lines 20-21 (inclusive) in <code>dotproductfma.cpp</code>. Replace the whole body of the <code>DotProductFMA</code> method (lines 29-52) with <code>return DotProductNative(u, v, n);</code>.</li>
<li>Delete the contents of <code>thirdparty/tesseract/src/arch/intsimdmatrixavx2.cpp</code> and <code>thirdparty/tesseract/src/arch/intsimdmatrixsse.cpp</code> (do not delete the files, just their contents).</li>
<li>Comment or delete lines 120-121 (inclusive) in <code>intsimdmatrix.h</code></li>
</ul>
</li>
<li>Open the <code>platform/win32/mupdf.sln</code> solution in Visual Studio. You should get a prompt to retarget your projects. Accept the default settings (latest Windows SDK and v143 of the tools).</li>
<li>In Visual Studio, click on the "Configuration Manager" item from the "Build" menu. In the new window, click on the drop down menu for the "Active solution platform" and select <code>&lt;New...&gt;</code>. In this new dialog, select the <code>ARM64</code> platform and choose to copy the settings from <code>x64</code>. Leave the <code>Create new project platforms</code> option enabled and click on <code>OK</code> (this may take some time).</li>
<li>Close the Configuration Manager and select the <code>ReleaseTesseract</code> configuration and <code>ARM64</code> architecture. Right-click on each project, to open its properties, then go to <code>C/C++</code> &gt; <code>Code Generation</code> and set the <code>Runtime Library</code> to <code>Multi-threaded DLL (/MD)</code> (ignore any project for which this option is not available).</li>
<li>Open the properties for the <code>libpkcs7</code> project, go to <code>C/C++</code> &gt; <code>Preprocessor</code> and remove <code>HAVE_LIBCRYPTO</code> from the <code>Preprocessor Definitions</code>. Then go to <code>Librarian</code> &gt; <code>General</code> and remove <code>libcrypto.lib</code> from the <code>Additional Dependencies</code>.</li>
<li>Save everything (<code>CTRL+SHIFT+S</code>) and close Visual Studio.</li>
<li>Create a new folder <code>platform/win32/Release</code>. Now, the problem is that the <code>bin2coff</code> script included with MuPDF cannot create <code>obj</code> files for ARM64 (only for x86 and x64). Since I could not find a version that can do this, I <a href="https://github.com/arklumpus/bin2coff">translated the source code of bin2coff to C# and added this option myself</a>. You can download an ARM64 <code>bin2coff.exe</code> from <a href="https://github.com/arklumpus/bin2coff/releases/latest/download/win-arm64.zip">here</a>; place it in the <code>Release</code> folder that you have just created.</li>
<li>Open the <code>Developer Command Prompt for VS</code>, move to the folder with the solution file (<code>platform/win32</code>), and build it using <code>msbuild mupdf.sln /p:Configuration=ReleaseTesseract</code>.</li>
<li>After a while, this should produce <code>libmupdf.lib</code> in the <code>ARM64/ReleaseTesseract</code> folder (the file should be ~388MB in size).</li>
</ul>
</li>
<li>On Linux (x64):<ul>
<li>Edit the <code>Makefile</code>, adding the <code>-fPIC</code> compiler option at the end of line 24 (which specifies the <code>CFLAGS</code>).</li>
<li>Make sure that you are using a recent enough version of GCC (version 7.3.1 seems to be enough).</li>
<li>Compile by running <code>USE_TESSERACT=yes make HAVE_X11=no HAVE_GLUT=no</code> (this builds just the command-line libraries and tools, and enables OCR through the included Tesseract library).</li>
</ul>
</li>
<li>On Linux (arm64):<ul>
<li>Edit the <code>Makefile</code>, adding the <code>-fPIC</code> compiler option at the end of line 24 (which specifies the <code>CFLAGS</code>).</li>
<li>Delete or comment line 218 in <code>thirdparty/tesseract/src/arch/simddetect.cpp</code>.</li>
<li>Make sure that you are using a recent enough version of GCC (version 7.3.1 seems to be enough).</li>
<li>Compile by running <code>USE_TESSERACT=yes make HAVE_X11=no HAVE_GLUT=no</code> (this builds just the command-line libraries and tools, and enables OCR through the included Tesseract library).</li>
</ul>
</li>
<li>On macOS (Intel - x64):<ul>
<li>Edit the <code>Makefile</code>, adding the <code>-fPIC</code> compiler option at the end of line 24 (which specifies the <code>CFLAGS</code>). Also add the <code>-std=c++11</code> option at the end of line 58 (which specifies the CXX_CMD).</li>
<li>Compile by running <code>USE_TESSERACT=yes make</code> (this enables OCR through the included Tesseract library).</li>
</ul>
</li>
<li>On macOS (Apple silicon - arm64)<ul>
<li>Edit the <code>Makefile</code>, adding the <code>-fPIC</code> compiler options at the end of line 24 (which specifies the <code>CFLAGS</code>). Also add the <code>-std=c++11</code> option at the end of line 58 (which specifies the CXX_CMD).</li>
<li>Compile by running <code>make</code> (this disables OCR, unfortunately - if you find a way to compile MuPDF with OCR support on Apple silicon, let me know).</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md12"></a>
2. Building MuPDFWrapper</h2>
<p>Once you have the required static library files, you should download the <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> source code: <a href="https://github.com/arklumpus/MuPDFCore/archive/v1.4.0.tar.gz">MuPDFCore-1.4.0.tar.gz</a> (or clone the repository) and place the library files in the appropriate subdirectories in the <code>native/MuPDFWrapper/lib/</code> folder.</p>
<p>To compile <code>MuPDFWrapper</code> you will need <a href="https://cmake.org/">CMake</a> (version 3.8 or higher) and (on Windows) <a href="https://ninja-build.org/">Ninja</a>.</p>
<p>On Windows, the easiest way to get all the required tools is probably to install <a href="https://visualstudio.microsoft.com/it/">Visual Studio</a>. By selecting the "Desktop development with C++" workload you should get everything you need.</p>
<p>On macOS, you will need to install at least the Command-Line Tools for Xcode (if necessary, you should be prompted to do this while you perform the following steps) and CMake.</p>
<p>Once you have everything at the ready, you will have to build MuPDFWrapper on the seven platforms.</p>
<h3><a class="anchor" id="autotoc_md13"></a>
Windows (x86 and x64)</h3>
<ol type="1">
<li></li>
</ol>
<p>Assuming you have installed Visual Studio, you should open the "&lt;strong&gt;x64&lt;/strong&gt; Native Tools Command Prompt for VS" or the "&lt;strong&gt;x86&lt;/strong&gt; Native Tools Command Prompt for VS" (you should be able to find these in the Start menu). Take care to open the version corresponding to the architecture you are building for, otherwise you will not be able to compile the library. A normal command prompt will not work, either.</p>
<p><b>Note 1</b>: you <b>must</b> build the library on two separate systems, one running a 32-bit version of Windows and the other running a 64-bit version. If you try to build the x86 library on an x64 system, the system will probably build a 64-bit library and place it in the 32-bit output folder, which will just make things very confusing.</p>
<p><b>Note 2 for Windows x86</b>: for some reason, Visual Studio might install the 64-bit version of CMake and Ninja, even though you are on a 32-bit machine. If this happens, you will have to manually install the 32-bit CMake and compile a 32-bit version of Ninja (which also requires Python to be installed). You will notice if this is an issue because the 64-bit programs will refuse to run.</p>
<ol type="1">
<li><code>CD</code> to the directory where you have downloaded the <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> source code.</li>
<li><code>CD</code> into the <code>native</code> directory.</li>
<li>Type <code>build</code>. This will start the <code>build.cmd</code> batch script that will delete any previous build and compile the library.</li>
</ol>
<p>After this finishes, you should find a file named <code>MuPDFWrapper.dll</code> in the <code>native/out/build/win-x64/MuPDFWrapper/</code> directory or in the <code>native/out/build/win-x86/MuPDFWrapper/</code> directory. Leave it there.</p>
<h3><a class="anchor" id="autotoc_md14"></a>
Windows (arm64)</h3>
<ol type="1">
<li>Locate the batch file that sets up the developer command prompt environment. You can do this by finding the "Developer Command Prompt for VS" link in the start menu, then clicking on <code>Open file location</code>, opening the properties of the link and looking at the <code>Target</code>. This could be e.g. <code>C:\Program Files\Microsoft Visual Studio\2022\Preview\Common7\Tools\VsDevCmd.bat</code>.</li>
<li>Open a normal command prompt and invoke the batch script with the <code>-arch=arm64 -host_arch=x86</code> arguments (add quotes if there are spaces in the path to the batch script), e.g.: ``` "C:\Program Files\Microsoft Visual Studio\2022\Preview\Common7\Tools\VsDevCmd.bat" -arch=arm64 -host_arch=x86 ``<code> 3.</code>CD<code>to the directory where you have downloaded the <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> source code. 4.</code>CD<code>into the</code>native<code>directory.</code></li>
<li><code>Type</code>build<code>. This will start the</code>build.cmd` batch script that will delete any previous build and compile the library.</li>
</ol>
<p>After this finishes, you should find a file named <code>MuPDFWrapper.dll</code> in the <code>native/out/build/win-arm64/MuPDFWrapper/</code> directory. Leave it there.</p>
<h3><a class="anchor" id="autotoc_md15"></a>
macOS and Linux</h3>
<ol type="1">
<li>Assuming you have everything ready, open a terminal in the folder where you have downloaded the <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> source code.</li>
<li><code>cd</code> into the <code>native</code> directory.</li>
<li>Type <code>chmod +x build.sh</code>.</li>
<li>Type <code>./build.sh</code>. This will delete any previous build and compile the library.</li>
</ol>
<p>After this finishes, you should find a file named <code>libMuPDFWrapper.dylib</code> in the <code>native/out/build/mac-x64/MuPDFWrapper/</code> directory (on macOS running on an Intel x64 processor) or in the <code>native/out/build/mac-arm64/MuPDFWrapper/</code> directory (on macOS running on an Apple silicon arm64 processor), and a file named <code>libMuPDFWrapper.so</code> in the <code>native/out/build/linux-x64/MuPDFWrapper/</code> directory (on Linux). Leave it there.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
3. Creating the MuPDFCore NuGet package</h2>
<p>Once you have the <code>MuPDFWrapper.dll</code>, <code>libMuPDFWrapper.dylib</code> and <code>libMuPDFWrapper.so</code> files, make sure they are in the correct folders (<code>native/out/build/xxx-yyy/MuPDFWrapper/</code>), <b>all on the same machine</b>.</p>
<p>To create the <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> NuGet package, you will need the <a href="https://dotnet.microsoft.com/download/dotnet/current">.NET Core 2.0 SDK or higher</a> for your platform. Once you have installed it and have everything ready, open a terminal in the folder where you have downloaded the <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> source code and type:</p>
<div class="fragment"><div class="line">cd MuPDFCore</div>
<div class="line">dotnet pack -c Release</div>
</div><!-- fragment --><p>This will create a NuGet package in <code>MuPDFCore/bin/Release</code>. You can install this package on your projects by adding a local NuGet source.</p>
<h2><a class="anchor" id="autotoc_md17"></a>
4. Running tests</h2>
<p>To verify that everything is working correctly, you should build the <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> test suite and run it on all platforms. To build the test suite, you will need the <a href="https://dotnet.microsoft.com/download/dotnet/current">.NET 6 SDK or higher</a>. You will also need to have enabled the <a href="https://docs.microsoft.com/en-us/windows/wsl/install">Windows Subsystem for Linux</a>.</p>
<p>To build the test suite:</p>
<ol type="1">
<li>Make sure that you have changed the version of the <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> NuGet package so that it is higher than the latest version of <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> in the NuGet repository (you should use a pre-release suffix, e.g. <code>1.4.0-a1</code> to avoid future headaches with new versions of <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a>). This is set in line 9 of the <code>MuPDFCore/MuPDFCore.csproj</code> file.</li>
<li>Add the <code>MuPDFCore/bin/Release</code> folder to your local NuGet repositories (you can do this e.g. in Visual Studio).</li>
<li>If you have not done so already, create the <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> NuGet package following step 3 above.</li>
<li>Update line 50 of the <code>Tests/Tests.csproj</code> project file so that it refers to the version of the <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> package you have just created.</li>
</ol>
<p>These steps ensure that you are testing the right version of <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> (i.e. your freshly built copy) and not something else that may have been cached.</p>
<p>Now, open a windows command line in the folder where you have downloaded the <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> source code, type <code>BuildTests</code> and press <code>Enter</code>. This will create a number of files in the <code>Release\MuPDFCoreTests</code> folder, where each file is an archive containing the tests for a certain platform and architecture:</p>
<ul>
<li><code>MuPDFCoreTests-linux-x64.tar.gz</code> contains the tests for Linux environments on x64 processors.</li>
<li><code>MuPDFCoreTests-linux-arm64.tar.gz</code> contains the tests for Linux environments on arm64 processors.</li>
<li><code>MuPDFCoreTests-mac-x64.tar.gz</code> contains the tests for macOS environments on Intel processors.</li>
<li><code>MuPDFCoreTests-mac-arm64.tar.gz</code> contains the tests for macOS environments on Apple silicon processors.</li>
<li><code>MuPDFCoreTests-win-x64.tar.gz</code> contains the tests for Windows environments on x64 processors.</li>
<li><code>MuPDFCoreTests-win-x86.tar.gz</code> contains the tests for Windows environments on x86 processors.</li>
</ul>
<p>To run the tests, copy each archive to a machine running the corresponding operating system, and extract it. Then:</p>
<h3><a class="anchor" id="autotoc_md18"></a>
Windows</h3>
<ul>
<li>Open a command prompt and <code>CD</code> into the folder where you have extracted the contents of the test archive.</li>
<li>Enter the command <code>MuPDFCoreTestHost</code> (this will run the test program).</li>
</ul>
<h3><a class="anchor" id="autotoc_md19"></a>
macOS and Linux</h3>
<ul>
<li>Open a terminal and <code>cd</code> into the folder where you have extracted the contents of the test archive.</li>
<li>Enter the command <code>chmod +x MuPDFCoreTestHost</code> (this will add the executable flag to the test program).</li>
<li>Enter the command <code>./MuPDFCoreTestHost</code> (this will run the test program).</li>
<li>On macOS, depending on your security settings, you may get a message saying <code>zsh: killed</code> when you try to run the program. To address this, you need to sign the executable, e.g. by running <code>codesign --timestamp --sign &lt;certificate&gt; MuPDFCoreTestHost</code>, where <code>&lt;certificate&gt;</code> is the name of a code signing certificate in your keychain (e.g. <code>Developer ID Application: John Smith</code>). After this, you can try again to run the test program with <code>./MuPDFCoreTestHost</code>.</li>
</ul>
<p>The test suite will start; it will print the name of each test, followed by a green <code>Succeeded</code> or a red <code>Failed</code> depending on the test result. If everything went correctly, all tests should succeed (except for the 5 OCR tests on Apple silicon Macs).</p>
<p>When all the tests have been run, the program will print a summary showing how many tests have succeeded (if any) and how many have failed (if any). If any tests have failed, a list of these will be printed, and then they will be run again one at a time, waiting for a key press before running each test (this makes it easier to follow what is going on). If you wish to kill the test process early, you can do so with <code>CTRL+C</code>.</p>
<h1><a class="anchor" id="autotoc_md20"></a>
Note about MuPDFCore and .NET Framework &lt;a name="netFrameworkNote"&gt;&lt;/a&gt;</h1>
<p>If you wish to use <a class="el" href="namespace_mu_p_d_f_core.html">MuPDFCore</a> in a .NET Framework project, you will need to manually copy the native MuPDFWrapper library for the platform you are using to the executable directory (this is done automatically if you target .NET/.NET core).</p>
<p>One way to obtain the appropriate library files is:</p>
<ol type="1">
<li>Manually download the NuGet package for <a href="https://www.nuget.org/packages/MuPDFCore/">MuPDFCore</a> (click on the "Download package" link on the right).</li>
<li>Rename the <code>.nupkg</code> file so that it has a <code>.zip</code> extension.</li>
<li>Extract the zip file.</li>
<li>Within the extracted folder, the library files are in the <code>runtimes/xxx/native/</code> folder, where <code>xxx</code> is <code>linux-x64</code>, <code>linux-arm64</code>, <code>osx-x64</code>, <code>osx-arm64</code>, <code>win-x64</code>, <code>win-x86</code> or <code>win-arm64</code>, depending on the platform you are using.</li>
</ol>
<p>Make sure you copy the appropriate file to the same folder as the executable! </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.18 </li>
  </ul>
</div>
</body>
</html>
